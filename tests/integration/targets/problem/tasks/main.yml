---
- environment:
    SN_HOST: "{{ sn_host }}"
    SN_USERNAME: "{{ sn_username }}"
    SN_PASSWORD: "{{ sn_password }}"

  block:
    - name: Retrieve problem records
      servicenow.itsm.problem_info:
      register: initial

    - name: Create a problem (check mode)
      servicenow.itsm.problem: &problem-create
        short_description: my-problem
        state: new
        attachments:
          - path: targets/problem/res/sample_file.txt
      register: first_problem
      check_mode: true
    - ansible.builtin.assert: &problem-create-assertions
        that:
          - first_problem is changed
          - first_problem.record.state == "new"
          - first_problem.record.short_description == "my-problem"
          - first_problem.record.attachments | length != 0
          - first_problem.record.attachments[0].file_name == "sample_file.txt"

    - name: Verify creation in check mode did not create a record
      servicenow.itsm.problem_info:
      register: result
    - ansible.builtin.assert:
        that:
          - result.records | length == initial.records | length

    - name: Create a problem
      servicenow.itsm.problem: *problem-create
      register: first_problem
    - ansible.builtin.assert: *problem-create-assertions

    - name: Verify that a new record was created
      servicenow.itsm.problem_info:
      register: result
    - ansible.builtin.assert:
        that:
          - result.records | length == initial.records | length + 1

    - name: Create a problem (idempotence)
      servicenow.itsm.problem:
        <<: *problem-create
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result is not changed

    - name: Update the problem (check mode)
      servicenow.itsm.problem: &problem-update
        sys_id: "{{ first_problem.record.sys_id }}"
        description: abc
        impact: high
        urgency: medium
        other:
          user_input: notes
      check_mode: true
      register: updated_problem
    - ansible.builtin.assert: &problem-update-assertions
        that:
          - updated_problem is changed
          - updated_problem.record.sys_id == first_problem.record.sys_id
          - updated_problem.record.description == "abc"
          - updated_problem.record.impact == "high"
          - updated_problem.record.urgency == "medium"
          - updated_problem.record.user_input == "notes"

    - name: Verify modification in check mode did not update the record
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records.0.description != "abc"

    - name: Update the problem
      servicenow.itsm.problem: *problem-update
      register: updated_problem
    - ansible.builtin.assert: *problem-update-assertions

    - name: Update the problem (idempotence)
      servicenow.itsm.problem: *problem-update
      register: result
    - ansible.builtin.assert:
        that:
          - result is not changed

    - name: Assign the problem to a non-existent user
      servicenow.itsm.problem:
        sys_id: "{{ first_problem.record.sys_id }}"
        state: assess
        assigned_to: nonexistent.user
      register: result
      ignore_errors: true
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'No sys_user records match' in result.msg"

    - name: Assign the problem for assessment
      servicenow.itsm.problem:
        sys_id: "{{ first_problem.record.sys_id }}"
        state: assess
        assigned_to: problem.manager
      register: assigned_problem

    - ansible.builtin.assert:
        that:
          - assigned_problem is changed
          - assigned_problem.record.state == "assess"
          - assigned_problem.record.assigned_to != ""

    - name: Mark the problem for root cause analysis
      servicenow.itsm.problem:
        sys_id: "{{ assigned_problem.record.sys_id }}"
        state: root_cause_analysis
        cause_notes: cause
      register: analyzed_problem
    - ansible.builtin.assert:
        that:
          - analyzed_problem is changed
          - analyzed_problem.record.state == "root_cause_analysis"
          - analyzed_problem.record.cause_notes == "cause"

    - name: Start fixing the problem
      servicenow.itsm.problem:
        sys_id: "{{ analyzed_problem.record.sys_id }}"
        state: fix_in_progress
        fix_notes: fix
      register: in_progress_problem
    - ansible.builtin.assert:
        that:
          - in_progress_problem is changed
          - in_progress_problem.record.state == "fix_in_progress"
          - in_progress_problem.record.fix_notes == "fix"

    - name: Resolve the problem
      servicenow.itsm.problem:
        sys_id: "{{ in_progress_problem.record.sys_id }}"
        state: resolved
        resolution_code: fix_applied
      register: resolved_problem
    - ansible.builtin.assert:
        that:
          - resolved_problem is changed
          - resolved_problem.record.state == "resolved"
          # FIXME: Uncomment the line below once the issue with setting resolution code at the ServiceNow side is resolved.
          #- resolved_problem.record.resolution_code == "fix_applied"

# FIXME: The task below causes '403 - Data Policy Exception: The following fields are mandatory: Resolution code'
# despite resolution_code being present in the request.
#
#    - name: Close the problem
#      servicenow.itsm.problem:
#        sys_id: "{{ resolved_problem.record.sys_id }}"
#        state: closed
#        resolution_code: fix_applied
#      register: closed_problem
#    - ansible.builtin.assert:
#        that:
#          - closed_problem is changed
#          - closed_problem.record.state == "resolved"
#          # FIXME: Uncomment the line below once the issue with setting resolution code at the ServiceNow side is resolved.
#          #- closed_problem.record.resolution_code == "fix_applied"


    - name: Create a bogus problem for cancellation
      servicenow.itsm.problem:
        state: assess
        short_description: cancel-me
        assigned_to: problem.manager
      register: bogus_problem

    - name: Cancel a problem
      servicenow.itsm.problem:
        sys_id: "{{ bogus_problem.record.sys_id }}"
        state: resolved
        resolution_code: canceled
        close_notes: closing
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed
          - result.record.state == "resolved"
          # FIXME: Uncomment the line below once the issue with setting resolution code at the ServiceNow side is resolved.
          #- result.record.resolution_code == "canceled"
          - result.record.close_notes == "closing"

    - name: Resolve a problem as a duplicate of a non-existent problem
      servicenow.itsm.problem:
        sys_id: "{{ assigned_problem.record.sys_id }}"
        state: closed
        resolution_code: duplicate
        duplicate_of: nonexistent-problem
      register: result
      ignore_errors: true
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'No problem records match' in result.msg"

    - name: Create a resolved problem that was fixed
      servicenow.itsm.problem:
        state: resolved
        short_description: fixed-problem
        assigned_to: problem.manager
        resolution_code: fix_applied
        cause_notes: cause
        fix_notes: fix
      register: fixed_problem
    - ansible.builtin.assert:
        that:
          - fixed_problem is changed
          - fixed_problem.record.resolution_code == "fix_applied"
          - fixed_problem.record.cause_notes == "cause"
          - fixed_problem.record.fix_notes == "fix"

    - name: Create a resolved problem with accepted risk
      servicenow.itsm.problem:
        state: resolved
        short_description: accepted-problem
        assigned_to: problem.manager
        resolution_code: risk_accepted
        cause_notes: cause
        close_notes: close
      register: risk_accepted_problem
    - ansible.builtin.assert:
        that:
          - risk_accepted_problem is changed
          - risk_accepted_problem.record.resolution_code == "risk_accepted"
          - risk_accepted_problem.record.cause_notes == "cause"
          - risk_accepted_problem.record.close_notes == "close"

    - name: Get specific problem info by sysparm query
      servicenow.itsm.problem_info:
        query:
         - number: = {{ risk_accepted_problem.record.number }}
           state: = resolved
           short_description: = accepted-problem
           assigned_to: = problem.manager
           resolution_code: = risk_accepted
           cause_notes: = cause
           close_notes: = close
      register: result

    - ansible.builtin.assert:
        that:
          - result.records | length == 1
          - result.records.0.number == risk_accepted_problem.record.number
          - result.records.0.state == "resolved"
          - result.records.0.short_description == "accepted-problem"
          - result.records.0.assigned_to != ""
          - result.records.0.resolution_code == "risk_accepted"
          - result.records.0.cause_notes == "cause"
          - result.records.0.close_notes == "close"

    - name: Get problem info by sysparm query - state and short_description
      servicenow.itsm.problem_info:
        query:
         - state: = resolved
           short_description: = accepted-problem
      register: result

    - ansible.builtin.assert:
        that:
          - result.records.0.state == "resolved"
          - result.records.0.short_description == "accepted-problem"

# FIXME: The task below causes '403 - Data Policy Exception: The following fields are mandatory: Resolution code'
# despite resolution_code being present in the request.
#
#    - name: Resolve a problem as a duplicate of another problem
#      servicenow.itsm.problem:
#        sys_id: "{{ assigned_problem.record.sys_id }}"
#        state: closed
#        resolution_code: duplicate
#        duplicate_of: "{{ fixed_problem.record.number }}"
#      register: result
#    - ansible.builtin.debug:
#        var: result.record
#    - ansible.builtin.assert:
#        that:
#          - result is changed
#          - result.record.state == "closed"
#          - result.record.duplicate_of == fixed_problem.record.sys_id
#          # FIXME: Uncomment the line below once the issue with setting resolution code at the ServiceNow side is resolved.
#          #- result.record.resolution_code == "duplicate"

    - name: Delete a problem (check mode)
      servicenow.itsm.problem: &problem-delete
        sys_id: "{{ first_problem.record.sys_id }}"
        state: absent
      check_mode: true
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed

    - name: Verify deletion in check mode did not remove the record
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records | length == 1

    - name: Delete a problem
      servicenow.itsm.problem: *problem-delete
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed

    - name: Verify that record was deleted
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records == []

    - name: Delete a problem (idempotency)
      servicenow.itsm.problem: *problem-delete
      register: result
    - ansible.builtin.assert:
        that:
          - result is not changed


    - name: Test bad parameter combinator (sys_id + query)
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
        query:
         - subcategory: = email
      ignore_errors: true
      register: result

    - ansible.builtin.assert:
        that:
          - result is failed
          - "'parameters are mutually exclusive: sys_id|query' in result.msg"


    - name: Test invalid operator detection
      servicenow.itsm.problem_info:
        query:
         - subcategory: == email
      ignore_errors: true
      register: result

    - ansible.builtin.assert:
        that:
          - result is failed
          - "'Invalid condition' in result.msg"


    - name: Get problem info by sysparm query - subcategory
      servicenow.itsm.problem_info:
        query:
         - subcategory: = email
      register: result

    - ansible.builtin.assert:
        that:
          - "'email' in result.records[0].subcategory"


    - name: Test unary operator with argument detection
      servicenow.itsm.problem_info:
        query:
         - short_description: ISEMPTY SAP
      ignore_errors: true
      register: result

    - ansible.builtin.assert:
        that:
          - result is failed
          - "'Operator ISEMPTY does not take any arguments' in result.msg"


    - name: Test sysparm query unary operator - short_description
      servicenow.itsm.problem_info:
        query:
         - short_description: ISNOTEMPTY
      register: result

    - ansible.builtin.assert:
        that:
          - result.records[0].short_description != ""
