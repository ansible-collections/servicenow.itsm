---
- environment:
    SN_HOST: "{{ sn_host }}"
    SN_USERNAME: "{{ sn_username }}"
    SN_PASSWORD: "{{ sn_password }}"

  vars:
    mapping:
      problem:
        state:
          101: "my_new"
          102: "assess"
          103: "root_cause"
          104: "progress"
          106: "resolved"
          107: "closed"
        impact:
          1: "highest"
          3: "lowest"
        urgency:
          2: "normal"
          3: "lowest"
  block:
    - name: Retrieve problem records
      servicenow.itsm.problem_info:
      register: initial

    - name: Create a problem (check mode)
      servicenow.itsm.problem: &problem-create
        problem_mapping: "{{ mapping.problem }}"
        short_description: my-problem
        state: my_new
        attachments:
          - path: targets/problem_with_mapping/res/sample_file.txt
      register: first_problem
      check_mode: true
    - ansible.builtin.assert: &problem-create-assertions
        that:
          - first_problem is changed
          - first_problem.record.state == "my_new"
          - first_problem.record.short_description == "my-problem"
          - first_problem.record.attachments | length != 0
          - first_problem.record.attachments[0].file_name == "sample_file.txt"

    - name: Verify creation in check mode did not create a record
      servicenow.itsm.problem_info:
      register: result
    - ansible.builtin.assert:
        that:
          - result.records | length == initial.records | length

    - name: Create a problem
      servicenow.itsm.problem: *problem-create
      register: first_problem
    - ansible.builtin.assert: *problem-create-assertions

    - name: Verify that a new record was created
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records | length == 1

    - name: Create a problem (idempotence)
      servicenow.itsm.problem:
        <<: *problem-create
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result is not changed

    - name: Update the problem (check mode)
      servicenow.itsm.problem: &problem-update
        sys_id: "{{ first_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        description: abc
        impact: highest
        urgency: normal
        other:
          user_input: notes
      check_mode: true
      register: updated_problem
    - ansible.builtin.assert: &problem-update-assertions
        that:
          - updated_problem is changed
          - updated_problem.record.sys_id == first_problem.record.sys_id
          - updated_problem.record.description == "abc"
          - updated_problem.record.impact == "highest"
          - updated_problem.record.urgency == "normal"
          - updated_problem.record.user_input == "notes"

    - name: Verify modification in check mode did not update the record
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records.0.description != "abc"

    - name: Update the problem
      servicenow.itsm.problem: *problem-update
      register: updated_problem
    - ansible.builtin.assert: *problem-update-assertions

    - name: Update the problem (idempotence)
      servicenow.itsm.problem: *problem-update
      register: result
    - ansible.builtin.assert:
        that:
          - result is not changed

    - name: Assign the problem to a non-existent user
      servicenow.itsm.problem:
        sys_id: "{{ first_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: assess
        assigned_to: nonexistent.user
      register: result
      ignore_errors: true
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'No sys_user records match' in result.msg"

    - name: Assign the problem for assessment
      servicenow.itsm.problem:
        sys_id: "{{ first_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: assess
        assigned_to: problem.manager
        urgency: normal
      register: assigned_problem
    - ansible.builtin.assert:
        that:
          - assigned_problem is changed
          - assigned_problem.record.state == "assess"
          - assigned_problem.record.assigned_to != ""
          - assigned_problem.record.urgency == "normal"

    - name: Mark the problem for root cause analysis
      servicenow.itsm.problem:
        sys_id: "{{ assigned_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: root_cause
        cause_notes: cause
      register: analyzed_problem
    - ansible.builtin.assert:
        that:
          - analyzed_problem is changed
          - analyzed_problem.record.state == "root_cause"
          - analyzed_problem.record.cause_notes == "cause"

    - name: Resolve a problem as a duplicate of a non-existent problem
      servicenow.itsm.problem:
        sys_id: "{{ analyzed_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: closed
        resolution_code: duplicate
        duplicate_of: nonexistent-problem
      register: result
      ignore_errors: true
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'No problem records match' in result.msg"

    - name: Start fixing the problem
      servicenow.itsm.problem:
        sys_id: "{{ analyzed_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: progress
        fix_notes: fix
      register: in_progress_problem
    - ansible.builtin.assert:
        that:
          - in_progress_problem is changed
          - in_progress_problem.record.state == "progress"
          - in_progress_problem.record.fix_notes == "fix"

    - name: Resolve the problem
      servicenow.itsm.problem:
        sys_id: "{{ in_progress_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: resolved
        resolution_code: fix_applied
      register: resolved_problem
    - ansible.builtin.assert:
        that:
          - resolved_problem is changed
          - resolved_problem.record.state == "resolved"
          - resolved_problem.record.resolution_code == "fix_applied"

    - name: Close the problem
      servicenow.itsm.problem:
        sys_id: "{{ resolved_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: closed
        resolution_code: fix_applied
        impact: highest
      register: closed_problem
    - ansible.builtin.assert:
        that:
          - closed_problem is changed
          - closed_problem.record.state == "closed"
          - closed_problem.record.resolution_code == "fix_applied"
          - closed_problem.record.impact == "highest"


    - name: Create a bogus problem for cancellation
      servicenow.itsm.problem:
        problem_mapping: "{{ mapping.problem }}"
        state: assess
        short_description: cancel-me
        assigned_to: problem.manager
      register: bogus_problem

    - name: Cancel a problem (fail)
      servicenow.itsm.problem:
        sys_id: "{{ bogus_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: resolved
        resolution_code: canceled
        close_notes: closing
      register: result
      ignore_errors: true
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'Problem state transition from state 102 to 106 is not possible' in result.msg"

    - name: Cancel a problem
      servicenow.itsm.problem:
        sys_id: "{{ bogus_problem.record.sys_id }}"
        problem_mapping: "{{ mapping.problem }}"
        state: closed
        resolution_code: canceled
        close_notes: closing
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed
          - result.record.state == "closed"
          - result.record.resolution_code == "canceled"
          - result.record.close_notes == "closing"

    - name: Create a resolved problem that was fixed
      servicenow.itsm.problem:
        state: resolved
        problem_mapping: "{{ mapping.problem }}"
        short_description: fixed-problem
        assigned_to: problem.manager
        resolution_code: fix_applied
        cause_notes: cause
        fix_notes: fix
      register: fixed_problem
    - ansible.builtin.assert:
        that:
          - fixed_problem is changed
          - fixed_problem.record.resolution_code == "fix_applied"
          - fixed_problem.record.cause_notes == "cause"
          - fixed_problem.record.fix_notes == "fix"

    - name: Create a resolved problem with accepted risk
      servicenow.itsm.problem:
        problem_mapping: "{{ mapping.problem }}"
        state: resolved
        short_description: accepted-problem
        assigned_to: problem.manager
        resolution_code: risk_accepted
        cause_notes: cause
        close_notes: close
      register: risk_accepted_problem
    - ansible.builtin.assert:
        that:
          - risk_accepted_problem is changed
          - risk_accepted_problem.record.resolution_code == "risk_accepted"
          - risk_accepted_problem.record.cause_notes == "cause"
          - risk_accepted_problem.record.close_notes == "close"

    - name: Get specific problem info by query
      servicenow.itsm.problem_info:
        query:
         - number: = {{ risk_accepted_problem.record.number }}
           state: = resolved
           short_description: = accepted-problem
           assigned_to: = problem.manager
           resolution_code: = risk_accepted
           cause_notes: = cause
           close_notes: = close
      register: result

    - ansible.builtin.assert:
        that:
          - result.records | length == 1
          - result.records.0.number == risk_accepted_problem.record.number
          - result.records.0.state == "resolved"
          - result.records.0.short_description == "accepted-problem"
          - result.records.0.assigned_to != ""
          - result.records.0.resolution_code == "risk_accepted"
          - result.records.0.cause_notes == "cause"
          - result.records.0.close_notes == "close"

    - name: Get problem info by query - state and short_description
      servicenow.itsm.problem_info:
        query:
         - state: = resolved
           short_description: = accepted-problem
      register: result
    - ansible.builtin.assert:
        that:
          - result.records.0.state == "resolved"
          - result.records.0.short_description == "accepted-problem"

    - name: Create a problem for resolution as a duplicate
      servicenow.itsm.problem:
        problem_mapping: "{{ mapping.problem }}"
        state: root_cause
        assigned_to: problem.manager
        short_description: a-duplicate
      register: duplicated_problem

    - name: Resolve a problem as a duplicate of another problem
      servicenow.itsm.problem:
        problem_mapping: "{{ mapping.problem }}"
        sys_id: "{{ duplicated_problem.record.sys_id }}"
        state: closed
        resolution_code: duplicate
        duplicate_of: "{{ assigned_problem.record.number }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed
          - result.record.state == "closed"
          - result.record.duplicate_of == assigned_problem.record.sys_id
          - result.record.resolution_code == "duplicate"

    - name: Delete a problem (check mode)
      servicenow.itsm.problem: &problem-delete
        problem_mapping: "{{ mapping.problem }}"
        sys_id: "{{ first_problem.record.sys_id }}"
        state: absent
      check_mode: true
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed

    - name: Verify deletion in check mode did not remove the record
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records | length == 1

    - name: Delete a problem
      servicenow.itsm.problem: *problem-delete
      register: result
    - ansible.builtin.assert:
        that:
          - result is changed

    - name: Verify that record was deleted
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
      register: result
    - ansible.builtin.assert:
        that:
          - result.records == []

    - name: Delete a problem (idempotency)
      servicenow.itsm.problem: *problem-delete
      register: result
    - ansible.builtin.assert:
        that:
          - result is not changed


    - name: Test bad parameter combinator (sys_id + query)
      servicenow.itsm.problem_info:
        sys_id: "{{ first_problem.record.sys_id }}"
        query:
         - subcategory: = email
      ignore_errors: true
      register: result
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'parameters are mutually exclusive: sys_id|query' in result.msg"


    - name: Test invalid operator detection
      servicenow.itsm.problem_info:
        query:
         - subcategory: == email
      ignore_errors: true
      register: result
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'Invalid condition' in result.msg"


    - name: Get problem info by sysparm query - subcategory
      servicenow.itsm.problem_info:
        query:
         - subcategory: = email
      register: result
    - ansible.builtin.assert:
        that:
          - "'email' in result.records[0].subcategory"


    - name: Test unary operator with argument detection
      servicenow.itsm.problem_info:
        query:
         - short_description: ISEMPTY SAP
      ignore_errors: true
      register: result
    - ansible.builtin.assert:
        that:
          - result is failed
          - "'Operator ISEMPTY does not take any arguments' in result.msg"


    - name: Test sysparm query unary operator - short_description
      servicenow.itsm.problem_info:
        query:
         - short_description: ISNOTEMPTY
      register: result
    - ansible.builtin.assert:
        that:
          - result.records[0].short_description != ""
